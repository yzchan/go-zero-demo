// Code generated by protoc-gen-go. DO NOT EDIT.
// source: iploc.proto

package iploc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type IpAddr struct {
	Ip                   string   `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpAddr) Reset()         { *m = IpAddr{} }
func (m *IpAddr) String() string { return proto.CompactTextString(m) }
func (*IpAddr) ProtoMessage()    {}
func (*IpAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_71ff6de436abb80f, []int{0}
}

func (m *IpAddr) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IpAddr.Unmarshal(m, b)
}
func (m *IpAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IpAddr.Marshal(b, m, deterministic)
}
func (m *IpAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpAddr.Merge(m, src)
}
func (m *IpAddr) XXX_Size() int {
	return xxx_messageInfo_IpAddr.Size(m)
}
func (m *IpAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_IpAddr.DiscardUnknown(m)
}

var xxx_messageInfo_IpAddr proto.InternalMessageInfo

func (m *IpAddr) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

type IpResult struct {
	A                    string   `protobuf:"bytes,1,opt,name=a,proto3" json:"a,omitempty"`
	B                    string   `protobuf:"bytes,2,opt,name=b,proto3" json:"b,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpResult) Reset()         { *m = IpResult{} }
func (m *IpResult) String() string { return proto.CompactTextString(m) }
func (*IpResult) ProtoMessage()    {}
func (*IpResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_71ff6de436abb80f, []int{1}
}

func (m *IpResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IpResult.Unmarshal(m, b)
}
func (m *IpResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IpResult.Marshal(b, m, deterministic)
}
func (m *IpResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpResult.Merge(m, src)
}
func (m *IpResult) XXX_Size() int {
	return xxx_messageInfo_IpResult.Size(m)
}
func (m *IpResult) XXX_DiscardUnknown() {
	xxx_messageInfo_IpResult.DiscardUnknown(m)
}

var xxx_messageInfo_IpResult proto.InternalMessageInfo

func (m *IpResult) GetA() string {
	if m != nil {
		return m.A
	}
	return ""
}

func (m *IpResult) GetB() string {
	if m != nil {
		return m.B
	}
	return ""
}

func init() {
	proto.RegisterType((*IpAddr)(nil), "iploc.IpAddr")
	proto.RegisterType((*IpResult)(nil), "iploc.IpResult")
}

func init() { proto.RegisterFile("iploc.proto", fileDescriptor_71ff6de436abb80f) }

var fileDescriptor_71ff6de436abb80f = []byte{
	// 131 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xce, 0x2c, 0xc8, 0xc9,
	0x4f, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x05, 0x73, 0x94, 0x24, 0xb8, 0xd8, 0x3c,
	0x0b, 0x1c, 0x53, 0x52, 0x8a, 0x84, 0xf8, 0xb8, 0x98, 0x32, 0x0b, 0x24, 0x18, 0x15, 0x18, 0x35,
	0x38, 0x83, 0x98, 0x32, 0x0b, 0x94, 0xd4, 0xb8, 0x38, 0x3c, 0x0b, 0x82, 0x52, 0x8b, 0x4b, 0x73,
	0x4a, 0x84, 0x78, 0xb8, 0x18, 0x13, 0xa1, 0x52, 0x8c, 0x89, 0x20, 0x5e, 0x92, 0x04, 0x13, 0x84,
	0x97, 0x64, 0xa4, 0xcf, 0xc5, 0xea, 0x59, 0xe0, 0x93, 0x9f, 0x2c, 0xa4, 0xc6, 0xc5, 0xe2, 0x96,
	0x99, 0x97, 0x22, 0xc4, 0xab, 0x07, 0xb1, 0x07, 0x62, 0xae, 0x14, 0x3f, 0x9c, 0x0b, 0x31, 0x2c,
	0x89, 0x0d, 0xec, 0x00, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfd, 0x91, 0xc3, 0x08, 0x8f,
	0x00, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IpLocClient is the client API for IpLoc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IpLocClient interface {
	Find(ctx context.Context, in *IpAddr, opts ...grpc.CallOption) (*IpResult, error)
}

type ipLocClient struct {
	cc *grpc.ClientConn
}

func NewIpLocClient(cc *grpc.ClientConn) IpLocClient {
	return &ipLocClient{cc}
}

func (c *ipLocClient) Find(ctx context.Context, in *IpAddr, opts ...grpc.CallOption) (*IpResult, error) {
	out := new(IpResult)
	err := c.cc.Invoke(ctx, "/iploc.IpLoc/Find", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IpLocServer is the server API for IpLoc service.
type IpLocServer interface {
	Find(context.Context, *IpAddr) (*IpResult, error)
}

// UnimplementedIpLocServer can be embedded to have forward compatible implementations.
type UnimplementedIpLocServer struct {
}

func (*UnimplementedIpLocServer) Find(ctx context.Context, req *IpAddr) (*IpResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}

func RegisterIpLocServer(s *grpc.Server, srv IpLocServer) {
	s.RegisterService(&_IpLoc_serviceDesc, srv)
}

func _IpLoc_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpLocServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iploc.IpLoc/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpLocServer).Find(ctx, req.(*IpAddr))
	}
	return interceptor(ctx, in, info, handler)
}

var _IpLoc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "iploc.IpLoc",
	HandlerType: (*IpLocServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Find",
			Handler:    _IpLoc_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iploc.proto",
}
